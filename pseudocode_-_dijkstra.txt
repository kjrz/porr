dijkstra(graph, source, destination):

	visited  [vertexesNumber] = {false,...,false}					// Initialisation
	previous [vertexesNumber] = {null,...,null}
	queue    [vertexesNumber] = {source,null,...,null}
	distances[vertexesNumber] = {infinity,...,infinity}
	distances[source]         = 0              
	
	while queue[0] != null:
		nearestUnvisited = null
		nearestDistance  = infinity
		
		for each element of queue									// get unvisited with shortest distance
			if element == null
				break
			else if distances[element] < nearestDistance
			&& !visited [element]:
				nearestUnvisited  = element
				nearestDistance = distances[element]
			
		queue[nearestUnvisited]   = null							// remove it from queue
		visited[nearestUnvisited] = true							// and mark as visited

		for each neighbor of nearestUnvisited:
			alternative = distances[nearestUnvisited]
				+ distance(nearestUnvisited, neighbor)				// accumulate shortest distance from source
			if alternative < distances[neighbor]
			&& !visited[neighbor]:                                 
				distances[neighbor] = alternative					// keep the shortest distance from source to neighbour
				previous [neighbor] = nearestUnvisited
				insert neighbor into Q                          	// add unvisited neighbour to queue for processing
